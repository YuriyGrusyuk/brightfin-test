"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolve = exports.LocalInstaller = void 0;
const lodash_flatmap_1 = __importDefault(require("lodash.flatmap"));
const events_1 = require("events");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const helpers_1 = require("./helpers");
const utils_1 = require("./utils");
const TEN_MEGA_BYTE = 1024 * 1024 * 10;
class LocalInstaller extends events_1.EventEmitter {
    constructor(sourcesByTarget, options) {
        super();
        this.sourcesByTarget = resolve(sourcesByTarget);
        this.options = Object.assign({}, options);
        this.uniqueDir = utils_1.getRandomTmpDir('node-local-install-');
    }
    on(event, listener) {
        // @ts-expect-error the 'listener' here is reduced to `never`
        return super.on(event, listener);
    }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
    async install() {
        await this.createTmpDirectory(this.uniqueDir);
        const packages = await this.resolvePackages();
        const installTargets = this.identifyInstallTargets(packages);
        await this.packAll();
        await this.installAll(installTargets);
        await this.removeTmpDirectory();
        return installTargets;
    }
    async createTmpDirectory(tmpDir) {
        return fs_1.promises.mkdir(tmpDir);
    }
    async installAll(installTargets) {
        this.emit('install_start', this.sourcesByTarget);
        await Promise.all(installTargets.map((target) => this.installOne(target)));
        this.emit('install_end');
    }
    async installOne(target) {
        const toInstall = target.sources.map((source) => resolvePackFile(this.uniqueDir, source.packageJson));
        const options = {
            cwd: target.directory,
            maxBuffer: TEN_MEGA_BYTE,
            env: this.options.npmEnv,
        };
        const { stdout, stderr } = await utils_1.exec('npm', ['i', '--no-save', '--no-package-lock', ...toInstall], options);
        this.emit('installed', target.packageJson.name, stdout.toString(), stderr.toString());
    }
    async resolvePackages() {
        const uniqueDirectories = new Set(Object.keys(this.sourcesByTarget).concat(lodash_flatmap_1.default(Object.keys(this.sourcesByTarget), (target) => this.sourcesByTarget[target])));
        const allPackages = Promise.all(Array.from(uniqueDirectories).map((directory) => helpers_1.readPackageJson(directory).then((packageJson) => ({
            directory,
            packageJson,
        }))));
        const packages = await allPackages;
        const packageByDirectory = {};
        packages.forEach((pkg) => (packageByDirectory[pkg.directory] = pkg.packageJson));
        return packageByDirectory;
    }
    identifyInstallTargets(packages) {
        const installTargets = Object.keys(this.sourcesByTarget).map((target) => ({
            directory: target,
            packageJson: packages[target],
            sources: this.sourcesByTarget[target].map((source) => ({
                directory: source,
                packageJson: packages[source],
            })),
        }));
        this.emit('install_targets_identified', installTargets);
        return installTargets;
    }
    async packAll() {
        const allSources = Array.from(new Set(lodash_flatmap_1.default(Object.keys(this.sourcesByTarget), (target) => this.sourcesByTarget[target])));
        this.emit('packing_start', allSources);
        await Promise.all(allSources.map((source) => this.packOne(source)));
        this.emit('packing_end');
    }
    async packOne(directory) {
        await utils_1.exec('npm', ['pack', directory], {
            cwd: this.uniqueDir,
            maxBuffer: TEN_MEGA_BYTE,
        });
        this.emit('packed', directory);
    }
    removeTmpDirectory() {
        return utils_1.del(this.uniqueDir);
    }
}
exports.LocalInstaller = LocalInstaller;
function resolvePackFile(dir, pkg) {
    // Don't forget about scoped packages
    const scopeIndex = pkg.name.indexOf('@');
    const slashIndex = pkg.name.indexOf('/');
    if (scopeIndex === 0 && slashIndex > 0) {
        // @s/b -> s-b-x.x.x.tgz
        return path_1.default.resolve(dir, `${pkg.name.substr(1, slashIndex - 1)}-${pkg.name.substr(slashIndex + 1)}-${pkg.version}.tgz`);
    }
    else {
        // b -> b-x.x.x.tgz
        return path_1.default.resolve(dir, `${pkg.name}-${pkg.version}.tgz`);
    }
}
function resolve(packagesByTarget) {
    const resolvedPackages = {};
    Object.keys(packagesByTarget).forEach((localTarget) => {
        resolvedPackages[path_1.default.resolve(localTarget)] = Array.from(new Set(packagesByTarget[localTarget].map((pkg) => path_1.default.resolve(pkg))));
    });
    return resolvedPackages;
}
exports.resolve = resolve;
//# sourceMappingURL=LocalInstaller.js.map